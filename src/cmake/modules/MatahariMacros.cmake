# Generator for files specific to DBus interface

# This macro takes name of the API and then creates two files
# matahari-${API}-dbus-glue.h and matahari-${API}-dbus-properties.h
# First one contains gobject definition generated by dbus-binding-tool
# Second one is definition of properties of the object
macro(generate_dbus_headers API XML)
    find_file(XSLTPROC xsltproc)
    find_file(BIND_TOOL dbus-binding-tool)
    find_file(DBUS_TO_C dbus-to-c.xsl
              ${CMAKE_CURRENT_SOURCE_DIR}/..
              /usr/share/matahari)

    # Convert dbus interface to glue and properties files
    add_custom_command(
        OUTPUT ${API}-dbus-glue.h
        COMMAND ${BIND_TOOL} --prefix=matahari --mode=glib-server
            --output=${API}-dbus-glue.h
            ${XML}
        COMMENT "Generating ${API}-dbus-glue.h"
        VERBATIM
    )

    add_custom_command(
        OUTPUT ${API}-dbus-properties.h
        COMMAND ${XSLTPROC} --output ${API}-dbus-properties.h
            ${DBUS_TO_C}
            ${XML}
        COMMENT "Generating ${API}-dbus-properties.h"
        VERBATIM
    )
endmacro(generate_dbus_headers)

# This macro will transform QMF interface XML to DBus interface XML file
# Arguments SCHEMAS - paths to XML schema files
macro(generate_dbus_interface SCHEMAS)
    find_file(SCHEMA_TO_DBUS schema-to-dbus.xsl
              ${CMAKE_CURRENT_SOURCE_DIR} /usr/share/matahari)
    find_file(XSLTPROC xsltproc)
    # Create dbus subdirectory
    execute_process(COMMAND mkdir -p ${CMAKE_CURRENT_BINARY_DIR}/dbus)
    foreach(SCHEMA ${SCHEMAS})
        # Generate files for each schema
        execute_process(
            COMMAND ${XSLTPROC} ${SCHEMA_TO_DBUS} ${SCHEMA}
            WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/dbus
        )
    endforeach(SCHEMA ${SCHEMAS})
endmacro(generate_dbus_interface)

# This macro will generate QMF definition files from QMF schema
# Argument SCHEMAS - paths to XML schema files
# Variable SCHEMA_SOURCES - list of generated cpp files (it can be added
#                           to add_executable command for proper compliation)
macro(generate_qmf_schemas SCHEMAS SCHEMA_SOURCES)
    set(regen_schema OFF)

    if (SCHEMA_SOURCES)
        # There are some already generated files, check if they
        # need to be regenerated
        foreach (schema_file ${SCHEMAS})
            foreach (file ${SCHEMA_SOURCES})
                if (EXISTS ${file})
                    if (${schema_file} IS_NEWER_THAN ${file})
                        set(regen_schema ON)
                        message("${schema_file} is newer than ${file}")
                    endif (${schema_file} IS_NEWER_THAN ${file})
                else (EXISTS ${file})
                    set(regen_schema ON)
                endif (EXISTS ${file})
            endforeach (file ${SCHEMA_SOURCES})
        endforeach (schema_file ${SCHEMAS})
    else (SCHEMA_SOURCES)
        # No already generated files => generate them
        set(regen_schema ON)
    endif (SCHEMA_SOURCES)

    if (regen_schema)
        # Regenerate everything
	    message(STATUS "Regenerating QMFv2 classes from: ${SCHEMAS}")
        execute_process(COMMAND rm -f ${SCHEMA_SOURCES})
        message("${QMFGEN} -2 -o ./qmf ${SCHEMAS}  in ${CMAKE_CURRENT_BINARY_DIR}")
        execute_process(COMMAND ${QMFGEN} -2 -o ./qmf ${SCHEMAS}
                        WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR})
    else (regen_schema)
        message(STATUS "No need to generate QMFv2 classes from: ${SCHEMAS}")
    endif (regen_schema)
endmacro(generate_qmf_schemas)
